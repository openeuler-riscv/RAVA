# 添加一个实体设备 - sg2042

## 为当前设备添加一个 Device Type

![添加设备类型 sg2042](./imgs/add_device_type_sg2042.png "添加设备类型 sg2042")

![Administration > Device Type > + Add](./imgs/set_sg2042_type.png "设置 sg2042 类型")

> Architecture 和 Processor 需要点击右侧 + 号添加，缺少的部分可以补充也可以留空

## 安装 tftp 并配置

sg2042 虽然不通过 tftp 获取并加载固件，内核，设备树相关文件，但在 deploy 阶段会将 kernel下载到 tftp 相关目录，所以需要先在 worker 机器上安装并配置 tftp。安装 lava-dispatcher 时应该会默认安装 tftpd-hpa ，若没有则：

```Bash
sudo apt install tftpd-hpa
```

tftp 配置文件类似于：

```TypeScript
zhtianyu@debian:~/lpi4a$ cat /etc/default/tftpd-hpa  
# /etc/default/tftpd-hpa 

TFTP_USERNAME="tftp" 
TFTP_DIRECTORY="/srv/tftp" 
TFTP_ADDRESS=":69" 
TFTP_OPTIONS="--secure"
```

## 安装 NFS server 并配置

sg2042 通过 NFS 的方式获取文件系统相关文件，需要在 worker 安装并配置 NFS server。安装 lava-dispatcher 时应该会默认安装 nfs-kernel-server ，若没有则：

```Bash
sudo apt install nfs-kernel-server
```

lava 默认会在`/etc/exports.d/lava-dispatcher-nfs.exports`配置 NFS 共享目录：

```Shell
zhtianyu@debian:~$ cat /etc/exports.d/lava-dispatcher-nfs.exports 
# /etc/exports: the access control list for filesystems which may be exported 
#               to NFS clients.  See exports(5). 
# 
# Example for NFSv2 and NFSv3: 
# /srv/homes       hostname1(rw,sync,no_subtree_check) hostname2(ro,sync,no_subtree_check) 
# 
# Example for NFSv4: 
# /srv/nfs4        gss/krb5i(rw,sync,fsid=0,crossmnt,no_subtree_check) 
# /srv/nfs4/homes  gss/krb5i(rw,sync,no_subtree_check) 
# 

/var/lib/lava/dispatcher/tmp *(rw,no_root_squash,async,no_subtree_check,crossmnt)
```

若没有配置，则：

```Plain
vim /etc/exports    
/var/lib/lava/dispatcher/tmp *(rw,no_root_squash,no_all_squash,async,no_subtree_check)
sudo service nfs-kernel-server restart   # 配置完成后重启 NFS server
```

### 准备 persistent\_nfs

由于 sg2042 的启动流程的限制，采用 persistent\_nfs 作为 sg2042 的 rootfs，需要在上述的 nfs 共享目录下准备 **sg2042\_rootfs**

```Shell
wget https://repo.tarsier-infra.isrc.ac.cn/openEuler-RISC-V/RVCK/openEuler24.03-LTS-SP1/openeuler-rootfs.tar.gz
sudo tar -xvf ../openeuler-rootfs.tar.gz -C /var/lib/lava/dispatcher/tmp/sg2042_rootfs
```

同时，需要清理上次测试的残留，需要每次启动测试前删除`/var/lib/lava/dispatcher/tmp/sg2042_rootfs`目录，并解压出一个干净的 rootfs 。可以在 worker 上准备一个 pre\_os\_command 脚本，在 job 中定义每次启动测试前执行 pre\_os\_command，同时 sg2042 的串口设备在使用长时间之后，可能会变得很不稳定，通过 usbreset 重置串口设备的 usb 接口：

```Bash
zhtianyu@debian:~$ cat sg2042/reset_nfsrootfs  
#!/bin/bash 

sudo -S rm -rf /var/lib/lava/dispatcher/tmp/sg2042_rootfs << EOF 
zhtianyu\r 
EOF 
sudo -S mkdir /var/lib/lava/dispatcher/tmp/sg2042_rootfs << EOF 
zhtianyu\r 
EOF 
sudo -S tar -zxf /home/zhtianyu/sg2042/openeuler-rootfs.tar.gz -C /var/lib/lava/dispatcher/tmp/sg2042_rootfs << EOF 
zhtianyu\r 
EOF 

sudo -S usbreset 001/010 << EOF 
zhtianyu\r 
EOF
```

## 在服务端添加 Worker 连接的 Device

在 LAVA 服务端命令行执行

`lava-server manage devices add --device-type sg2042 --worker cipu-zz-debian-01 sg2042-01`

执行成功后在 Web 界面`Scheduler > Devices`可以查询到

![查看 sg2042 设备](./imgs/sg2042_device.png "查看 sg2042 设备")

## 为 sg2042 添加 device-type 基础模板

将 sg2042 的 device-type 存储在 server 下的 `/etc/lava-server/dispatcher-config/device-types/sg2042.jinja2` 中

```YAML
{% extends 'base-uboot.jinja2' %} 

{% set uboot_mkimage_arch = 'riscv' %} 

{% set console_device = console_device|default('ttyS0') %}  
{% set baud_rate = baud_rate|default(115200) %}  

{% set boot_character_delay = 100 %} 

{% set booti_kernel_addr = '0x00200000' %}  
{% set booti_dtb_addr = '0x03800000' %}        
{% set booti_ramdisk_addr = '0x06000000' %}  

{% set interrupt_prompt = interrupt_prompt | default('Enter an option') %} 
{% set interrupt_char = interrupt_char | default('6') %} 

{% set bootloader_prompt = bootloader_prompt|default('root@mango') %} 

{% set bootloader_commands = [] %} 

{% set uboot_final_message = uboot_final_message | default("Linux version") %} 

{% set kernel_start_message = kernel_start_message | default('openEuler') %}
```

### 编写 device-type 模板的流程

首先可以到 [device-types](https://github.com/Linaro/lava/tree/master/etc/dispatcher-config/device-types) 查看是否有已存在的 device-type 模板，如果都没有的话，就需要我们自己编写了。以下为编写 sg2042 的模板的步骤：

1. 了解板卡启动方式，目前 sg2042 只能通过 linuxboot 启动，具体的启动方式是在 worker 上配置 pxelinux.cfg，在 sg2042 启动后进入 LinuxBoot shell ，在命令行中先通过 dhclient eth0 获取网络，然后 pxeboot -file tftp://10.213.5.176/pxelinux.cfg/default -server 10.213.5.176 来从 worker 上获取启动文件后启动，其中default 配置文件中写明 nfsroot=10.213.5.176:/var/lib/lava/dispatcher/tmp/sg2042\_rootfs,tcp,hard,vers=4.1 rw 用于启动时挂载 persistent\_nfs 。
2. 依托已存在的 `base-uboot.jinja2` ，对 sg2042 的启动过程进行适配，只在 device-type 中做基础的配置，通过脚本生成需要的启动文件。

编写方法可以参考https://validation.linaro.org/static/docs/v2/device-integration.html，已有的 device-type 可以查看 https://github.com/Linaro/lava/tree/master/etc/dispatcher-config/device-types

> sg2042 通过 linuxboot 启动，但 lava 中对于该流程没有相关的适配，目前可以通过已存在的 device-type 和 job 中的相关定义完成启动流程。最合理的方式应该在 lava 中适配 linuxboot 的流程。不过适配可能需要大量的工作，暂且采用当前的方式完成接入。

### sg2042 device-type 基础模板详解

1. ​**扩展基模板**​：
   ```YAML
   {% extends 'base-uboot.jinja2' %}
   ```
   
   1. 该行表示当前模板从 `base-uboot.jinja2` 继承
2. ​**设置变量**​：
   ```YAML
   {% set console_device = console_device|default('ttyS0') %}
   {% set baud_rate = baud_rate|default(115200) %}
   ```
   
   1. `console_device`：设置控制台设备，默认为 `ttyS0`，如果未传递其他值。需要注意的是，就 sg2042 而言，这里指的是 sg2042 的控制台设备，而不是 worker 连接 sg2042 的串口设备，保持 `ttyS0` 即可
   2. `baud_rate`：设置波特率，默认为 `115200`。
3. **设置**​**内存**​​**地址**​：
   ```YAML
   {% set booti_kernel_addr = '0x00202000' %}  
   {% set booti_dtb_addr = '0x03800000' %}      
   {% set booti_ramdisk_addr = '0x06000000' %}
   ```
   
   1. `booti_kernel_addr`：内核的加载地址。
   2. `booti_dtb_addr`：设备树 Blob (DTB) 的加载地址。
   3. `booti_ramdisk_addr`：初始 RAM 磁盘的加载地址。
   
   > 根据启动流程来说，并不需要这些​**加载地址**​，但如果不设置的话会报错：Invalid job data: ["Requested kernel boot type 'bootm' is not supported by this device."]
4. ​**设置 lava 输入字符的间隔**​：
   ```YAML
   {% set boot_character_delay = 100 %}
   ```
   
   1. `boot_character_delay`：设置 lava 输入字符的时间，主要是为了模拟人类键盘输入，电脑输入过快可能会造成字符倒置等情况
5. ​**设置 lava 如何进入 linuxboot shell**​：
   ```YAML
   {% set interrupt_prompt = interrupt_prompt | default('Enter an option') %} 
   {% set interrupt_char = interrupt_char | default('6') %} 
   {% set bootloader_prompt = bootloader_prompt|default('root@mango') %}
   ```
   
   1. `interrupt_prompt`：设置 lava 识别到 linuxboot**​ ​**的提示词 `Enter an option`
   2. `interrupt_char`：识别到 linuxboot**​ ​**的提示词后输入 6 进入 linuxboot shell
   3. `bootloader_prompt`：设置 linuxboot 的输入提示词，类似 lpi4a 的 'Light LPI4A# '
6. **设置 kernel 的启动提示信息：**
   ```YAML
   {% set bootloader_commands = [] %} 
   {% set uboot_final_message = uboot_final_message | default("Linux version") %}
   {% set kernel_start_message = kernel_start_message | default('openEuler') %}
   ```
   
   1. `bootloader_commands`：设置为空，在 job 中定义 boot 命令
   2. `uboot_final_message`：设置 linuxboot 启动成功的提示
   3. `kernel_start_message`：设置 kernel 的启动提示，lava 检测到 `openEuler` 字段后进入 login-action

## 配置 sg2042 连接方式

这里选择使用串口连接

* 如果要使用远程设备，lava-dispatcher 的依赖中包括了`ser2net`，可以通过这个方式对设备进行访问

### 使用 ser2net 为串口打开一个网络连接

#### 安装 ser2net

```Shell
sudo apt install ser2net
sudo vim /etc/ser2net.yaml     //配置串口信息
```

#### 配置 ser2net

笔者使用的串口设备在`/dev/ttyACM0`，sg2042 的串口波特率为 115200

编辑文件`/etc/ser2net.yaml`，将其暴露在 15202 端口上

```yaml
connection: &con1152A0 
    accepter: tcp,localhost,15202 
    enable: on 
    options: 
      banner: *banner 
      kickolduser: true 
      telnet-brk-on-sync: true 
    connector: serialdev, 
              /dev/ttyACM0, 
              115200n,local,-rtscts
```

## 配置 sg2042 ha 控制开关机（需要线下协助）

将 sg2042 电源连接到 ha 的插座上，并获取对应的 entity\_id

将控制电源开关的 curl 命令保存到 worker 机器上，如 `/home/zhtianyu/sg2042/`

```Bash
zhtianyu@debian:~$ cat sg2042/power_on 
#!/bin/bash 

curl -X POST -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiI1OWMyNzM3OWRjMDU0ZjlhOWFiZDU5ZDNiM2MzZGUxMCIsImlhdCI6MTc0ODA2
ODEzNSwiZXhwIjoyMDYzNDI4MTM1fQ.xltJlQbzS6qyVTGbbL6q1hVdaxODWfz_fbv78JNq6zc" -H "Content-Type: application/json" -d '{"entity_id":"switch.cuco_cn_631
987411_cp1d_on_p_2_1"}' http://10.213.5.145:8123/api/services/switch/turn_on 
zhtianyu@debian:~$ cat lpi4a/power_off 
#!/bin/bash 

curl -X POST -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiI1OWMyNzM3OWRjMDU0ZjlhOWFiZDU5ZDNiM2MzZGUxMCIsImlhdCI6MTc0ODA2
ODEzNSwiZXhwIjoyMDYzNDI4MTM1fQ.xltJlQbzS6qyVTGbbL6q1hVdaxODWfz_fbv78JNq6zc" -H "Content-Type: application/json" -d '{"entity_id":"switch.cuco_cn_631
866757_cp1d_on_p_2_1"}' http://10.213.5.145:8123/api/services/switch/turn_off 
zhtianyu@debian:~$ cat lpi4a/hard_reset 
#!/bin/bash 
cd /home/zhtianyu/lpi4a || exit 1 
./power_off && sleep 10 && ./power_on
```

如果使用的是同样的电源控制方案，其中应填写与实际环境中一致的参数，如 `Authorization`，`entity_id`，以及对应的 `url` 地址。

## 为 sg2042 的 initramfs.img 添加 NFS 模块

由于 sg2042 的 initramfs.img 没有 NFS 模块，如果在启动时挂载 nfs 作为 rootfs ，会报错。需要为 sg2042 的 initramfs.img 添加 NFS 模块。进入刚烧录好的 sg2042，执行下述操作

```Shell
cd /boot
cp initramfs-6.6.0-98.0.0.103.oe2403sp2.riscv64.img initramfs.img
dracut -f --add-drivers "nfs sunrpc" /boot/initramfs.img
```

## 配置 sg2042 的 pxelinux.cfg

sg2042 的启动方式是通过 pxeboot 启动的，启动时需要获取 pxelinux.cfg，需要在 pxelinux.cfg 下生成启动文件，首先在 /home/sg2042/ 目录下初始化 default 模板文件，为需要启动的 kernel 和 dtb 文件目录设置占位符，同时定义nfsrootfs 的目录，nfsroot 中 10.213.5.176 为 worker 的 ip，/var/lib/lava/dispatcher/tmp/sg2042\_rootfs 为之前配置好的 persistent\_nfs 共享地址：

```Bash
zhtianyu@debian:~/sg2042$ cat default  
title openEuler Boot Menu 
prompt 0 
timeout 3 
default LAVA_MVP 

label LAVA_MVP 
    menu label openEuler | LAVA Milk-V Pioneer 
    linux {KERNEL} 
    initrd /sg2042/initramfs.img 
    fdt {DTB} 
    append root=/dev/nfs nfsroot=10.213.5.176:/var/lib/lava/dispatcher/tmp/sg2042_rootfs,tcp,hard,vers=4.1 rw rootwait console=tty
S0,115200 earlycon selinux=0 ip=dhcp LANG=en_US.UTF-8 nvme.use_threaded_interrupts=1 nvme_core.io_timeout=3000
```

在 tftp 共享目录下初始化 pxelinux.cfg：

```Plain
sudo mkdir -p /srv/tftp/pxelinux.cfg/
```

编写 generate\_pxelinux 脚本用于生成 `/srv/tftp/pxelinux.cfg/default`：

```Bash
zhtianyu@debian:~$ cat sg2042/generate_pxelinux  
#!/bin/sh 
set -e 

# 获取环境变量 LAVA_JOB_ID 用于寻找 kernel 和 dtb 的位置
env_file=$(ls -d /var/lib/lava/dispatcher/tmp/sg2042_rootfs/lava-*/environment | head -n1) 
. "$env_file" 

# 默认路径
TFTP_BASE="/srv/tftp" 
JOB_DIR="${TFTP_BASE}/${LAVA_JOB_ID}/tftp-deploy-*" 

# 自动找到 kernel 和 dtb 文件
KERNEL=$(find $JOB_DIR/kernel -name 'Image' | head -n1) 
DTB=$(find $JOB_DIR/dtb -name '*.dtb' | head -n1) 

if [ -z "$KERNEL" ] || [ -z "$DTB" ]; then 
    echo "Error: kernel or dtb not found for job $LAVA_JOB_ID" 
    exit 1 
fi 

JOB_CFG_DIR="${TFTP_BASE}/pxelinux.cfg" 

# 清理旧 default
sudo -S rm -f "${TFTP_BASE}/pxelinux.cfg/default" << EOF 
zhtianyu\r 
EOF 

# 复制模板
sudo -S cp /home/zhtianyu/sg2042/default "${TFTP_BASE}/pxelinux.cfg/default" << EOF 
zhtianyu\r 
EOF 

# 转换成相对路径（去掉 /srv/tftp 前缀）
KERNEL_REL=${KERNEL#$TFTP_BASE/} 
DTB_REL=${DTB#$TFTP_BASE/} 

# 替换模板里的变量
sudo -S sed -i \ 
    -e "s|{KERNEL}|${KERNEL_REL}|g" \ 
    -e "s|{DTB}|${DTB_REL}|g" \ 
    "${TFTP_BASE}/pxelinux.cfg/default" << EOF 
zhtianyu\r 
EOF 

echo "Generated pxelinux.cfg for job $LAVA_JOB_ID" 
echo "Kernel: $KERNEL" 
echo "DTB: $DTB"
```

## 为设备编写 Device 文件

新建 sg2042 设备的 Device Dictionary 文件，将其存储在 server 下的 `/etc/lava-server/dispatcher-config/devices/sg2042-01.jinja2` 中

⚠️ **这里的 jinja2 文件名称需要和新添加的 Device 名称保持一致**

### 向 LAVA 描述如何连接远端串口

在配置完成 sg2042 的 ser2net 连接方式之后，为`sg2042-01.jinja2`添加[通过串口方式连接](https://docs.lavasoftware.org/lava/connections.html?highlight=ssh#configuring-serial-ports)的描述

```YAML
{% set connection_list = ['uart0'] %} 
{% set connection_commands = {'uart0': 'telnet localhost 15202'} %} 
{% set connection_tags = {'uart0': ['primary', 'telnet']} %}
```

### 向 LAVA 描述如何控制设备开关机

配置 sg2042 的 home-assistant 之后，为`sg2042-01.jinja2`添加控制设备开关机的描述

```YAML
{% set power_off_command = '/home/zhtianyu/sg2042/power_off' %} 
{% set power_on_command = '/home/zhtianyu/sg2042/power_on' %} 
{% set hard_reset_command = '/home/zhtianyu/sg2042/hard_reset' %} 
{% set soft_reset_command = '/home/zhtianyu/sg2042/hard_reset' %}
```

### 设置 persistent\_nfs 服务端 ip ，以及重置 rootfs 的脚本和配置 pxelinux.cfg 的脚本

```Shell
{% set static_info = [{'FILE_SERVER_IP': "10.213.5.176"}] %}
{% set pxelinux_generate = '/home/zhtianyu/sg2042/generate_pxelinux' %} 
{% set pre_os_command = '/home/zhtianyu/sg2042/reset_nfsrootfs' %} 

{% set user_commands = {'pxelinux_generate': {'do': '/home/zhtianyu/sg2042/generate_pxelinux', 'undo': 'echo "noop"'}, 
                        'pre_os_command': {'do': '/home/zhtianyu/sg2042/reset_nfsrootfs', 'undo': 'echo "noop"'}} %}
```

最后 `/etc/lava-server/dispatcher-config/devices/sg2042-01.jinja2` 中内容应该类似：

```Java
{% extends 'sg2042.jinja2' %} 

{% set device_type = 'sg2042' %} 

{% set connection_list = ['uart0'] %} 
{% set connection_commands = {'uart0': 'telnet localhost 15202'} %} 
{% set connection_tags = {'uart0': ['primary', 'telnet']} %} 

{% set static_info = [{'FILE_SERVER_IP': "10.213.5.176"}] %} 

{% set power_off_command = '/home/zhtianyu/sg2042/power_off' %} 
{% set power_on_command = '/home/zhtianyu/sg2042/power_on' %} 
{% set hard_reset_command = '/home/zhtianyu/sg2042/hard_reset' %} 
{% set soft_reset_command = '/home/zhtianyu/sg2042/hard_reset' %} 
{% set pxelinux_generate = '/home/zhtianyu/sg2042/generate_pxelinux' %} 
{% set pre_os_command = '/home/zhtianyu/sg2042/reset_nfsrootfs' %} 

{% set user_commands = {'pxelinux_generate': {'do': '/home/zhtianyu/sg2042/generate_pxelinux', 'undo': 'echo "noop"'}, 
                        'pre_os_command': {'do': '/home/zhtianyu/sg2042/reset_nfsrootfs', 'undo': 'echo "noop"'}} %}
```

### device type template 与 device dictionary 的关系

#### device type template（设备类型模板）

* ​**定义位置**​：通常在 `/etc/lava-server/dispatcher-config/device-types/` 目录下。
* ​**内容**​：是 Jinja2 模板（`.jinja2`），描述某一类设备（如 qemu、rpi4、hikey、x86）的通用特性，比如 sg2042.jinja2 中的部分配置：
  继承了`base-uboot.jinja2`，即复用了 U-Boot 的**通用配置，再加上 sg2042 设备的专用设置**
  
  配置了设置控制台设备和波特率
  
  设置内存地址。
* ​**特点**​：
  
  * 通用模板，不绑定某一台 ​**sg2042**​，而是 ​**所有 sg2042 设备共用**​。
  * 提供统一的部署/启动/测试逻辑。
  * 可以通过 **变量覆盖 ​**来自字典文件。

#### device dictionary（设备字典）

* ​**定义位置**​：通常在 `/etc/lava-server/dispatcher-config/devices/` 目录下，每台真实设备一个 jinja2 文件。
* ​**内容**​：描述某一台 **具体设备** 的信息，比如`sg2042`​`-`​`01.jinja2`：
  
  * **继承**​**关系**`extends 'sg2042.jinja2'`  → 说明这个具体设备基于 `sg2042.jinja2`（也就是 `sg2042` 的设备类型模板），继承了模板里的所有通用配置。
  * **设备唯一信息**
    ​**connection\_list / connection\_commands**​：定义了串口连接方式，使用 telnet 本地端口 `15202` 访问 UART。
    ​**​     connection\_tags**​：标记 uart0 是主连接（primary），使用 telnet。
  
  ​**​     power\_on/off/reset/pre\_os\_command**​：指定如何控制这台设备的电源和复位，以及测试前重置 persistent\_nfs，用的是本地脚本（如`/home/zhtianyu/sg2042/power_on` 等）。
* ​**特点**​：它是实例化的，一台设备一个文件，​**文件名称对应具体 device 的 hostname**​。

## sg2042 job

```YAML
device_type: sg2042
job_name: sg2042-boot-test
timeouts:
  job:
    minutes: 301
  action:
   minutes: 300
  actions:
    power-off:
      seconds: 30
priority: medium
visibility: public
metadata:
  # please change these fields when modifying this job for your own tests.
  format: Lava-Test Test Definition 1.0
  name: sg2042-boot-test
  description: "test for sg2042"
  version: "1.0"
# ACTION_BLOCK
actions:
- command:
    name: pre_os_command
    timeout:
          minutes: 20
# DEPLOY_BLOCK
- deploy:
    timeout:
      minutes: 20
    to: tftp
    os: debian
    kernel:
      url: http://10.211.102.58/kernel-build-results/rvck-olk_pr_98/Image
      type: image
    dtb:
      url: http://10.211.102.58/kernel-build-results/rvck-olk_pr_98/dtb/mango-milkv-pioneer.dtb
    persistent_nfs:
      address: "{FILE_SERVER_IP}:/var/lib/lava/dispatcher/tmp/sg2042_rootfs"
- command:
    name: pxelinux_generate
    timeout:
          minutes: 20
# BOOT_BLOCK
- boot:
    timeout:
      minutes: 200
    method: u-boot
    commands:
      - "dhclient eth0"
      - "pxeboot -file tftp://{SERVER_IP}/pxelinux.cfg -server {SERVER_IP}"
    soft_reboot:
    - root
    - openEuler
    - reboot
    - The system will reboot now!
    prompts: ["root@openeuler-riscv64", "login:", "Password:"]
    auto_login:
      login_prompt: "(.*)openeuler-riscv64 login:(.*)"
      username: root
      password_prompt: "Password:"
      password: openEuler12#$
- test:
      timeout:
        minutes: 100
      definitions:
        - repository: https://github.com/RVCK-Project/lavaci.git
          from: git
          name: ltp-math-lpi4a
          path: lava-testcases/common-test/ltp/ltp.yaml
          parameters:
            TST_CMDFILES: math
```

### sg2042 的 Job 基础配置

sg2042 的 Job 基础配置，包括 device\_type 和 job\_name 等描述。

```YAML
device_type: sg2042
job_name: sg2042-boot-test
timeouts:
  job:
    minutes: 301
  action:
   minutes: 300
  actions:
    power-off:
      seconds: 30
priority: medium
visibility: public
metadata:
  # please change these fields when modifying this job for your own tests.
  format: Lava-Test Test Definition 1.0
  name: sg2042-boot-test
  description: "test for sg2042"
  version: "1.0"
```

### 测试前清理上次测试的残留

pre\_os\_command 为清理上次测试的残留，并解压出一个干净的 rootfs，pre\_os\_command 脚本在 device 文件中配置好，并且在 worker 上准备好。

```Shell
# ACTION_BLOCK
- command:
    name: pre_os_command
    timeout:
          minutes: 20
```

### deploy 阶段

定义 kernel 和 dtb 文件通过 tftp 从 worker 加载到设备并启动，persistent\_nfs 为之前在 worker 的上配置好的 rootfs 目录。其中的 FILE\_SERVER\_IP 是在 device dictionary 中配置好的。另外运行 pxelinux\_generate 脚本用于准备 pxelinux.cfg 配置

```YAML
# DEPLOY_BLOCK
- deploy:
    timeout:
      minutes: 20
    to: tftp
    os: debian
    kernel:
      url: http://10.211.102.58/kernel-build-results/rvck-olk_pr_98/Image
      type: image
    dtb:
      url: http://10.211.102.58/kernel-build-results/rvck-olk_pr_98/dtb/mango-milkv-pioneer.dtb
    persistent_nfs:
      address: "{FILE_SERVER_IP}:/var/lib/lava/dispatcher/tmp/sg2042_rootfs"
- command:
    name: pxelinux_generate
    timeout:
          minutes: 20
```

### boot 和 test 阶段：启动待测试的 kernel 和 dtb 文件并进行测试

sg2042 的 device-type template 文件继承自 u-boot，定义 method: u-boot ，commands 中的 nfs 等无法使用以及完整覆写，在 job 中定义 `dhclient -ipv6=false eth0` 获取网络，然后 `pxeboot` 启动，登陆后执行测试

```YAML
# BOOT_BLOCK
- boot:
    timeout:
      minutes: 200
    method: u-boot
    commands:
      - "dhclient eth0"
      - "pxeboot -file tftp://{SERVER_IP}/pxelinux.cfg -server {SERVER_IP}"
    soft_reboot:
    - root
    - openEuler
    - reboot
    - The system will reboot now!
    prompts: ["root@openeuler-riscv64", "login:", "Password:"]
    auto_login:
      login_prompt: "(.*)openeuler-riscv64 login:(.*)"
      username: root
      password_prompt: "Password:"
      password: openEuler12#$
- test:
      timeout:
        minutes: 100
      definitions:
        - repository: https://github.com/RVCK-Project/lavaci.git
          from: git
          name: ltp-math-lpi4a
          path: lava-testcases/common-test/ltp/ltp.yaml
          parameters:
            TST_CMDFILES: math
```
